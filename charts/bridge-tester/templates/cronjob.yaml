{{- $opSecrets := (lookup "v1" "Secret" .Release.Namespace .Values.existingSecret) }}

apiVersion: batch/v1
kind: CronJob
metadata:
  name: {{ include "bridgeTester.fullname" . }}
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "bridgeTester.labels" . | nindent 4 }}
spec:
  schedule: {{ .Values.schedule | quote }}
  concurrencyPolicy: {{ .Values.concurrencyPolicy }}
  failedJobsHistoryLimit: {{ .Values.failedJobsHistoryLimit }}
  successfulJobsHistoryLimit: {{ .Values.successfulJobsHistoryLimit }}
  jobTemplate:
    spec:
      backoffLimit: {{ .Values.backoffLimit }}
      template:
        metadata:
          labels:
            {{- include "bridgeTester.labels" . | nindent 12 }}
            {{- with .Values.podLabels }}
            {{- toYaml . | nindent 12 }}
            {{- end }}
        spec:
          containers:
            - name: script-runner
              image: ubuntu:latest
              command: ["/bin/bash"]
              args:
                - -c
                - |
                  # JSON logging function for Datadog
                  log_json() {
                    local level="$1"
                    local message="$2"
                    local network="${3:-}"
                    local step="${4:-}"
                    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")

                    printf '{"timestamp":"%s","level":"%s","message":"%s"' "$timestamp" "$level" "$message"
                    [ -n "$network" ] && printf ',"network":"%s"' "$network"
                    [ -n "$step" ] && printf ',"step":"%s"' "$step"
                    printf ',"service":"bridge-tester","env":"{{ $.Values.env }}"}\n'
                  }

                  log_json "info" "Starting bridge-tester script" "" "init"

                  log_json "info" "Apt update and install deps" "" "install_deps"
                  apt-get update -qq && apt-get install -y -qq curl > /dev/null 2>&1

                  log_json "info" "Installing the latest version of polygon-cli for linux amd64" "" "install_polycli"
                  if curl -s --max-time 30 https://api.github.com/repos/0xPolygon/polygon-cli/releases/latest \
                    | grep "browser_download_url" \
                    | grep "linux_amd64" \
                    | cut -d '"' -f 4 \
                    | xargs -n 1 curl -sLO; then
                    tar -xzf polycli*.tar.gz
                    rm polycli*.tar.gz
                    chmod +x polycli*
                    mv polycli* /usr/local/bin/polycli
                    if polycli version > /dev/null 2>&1; then
                      POLYCLI_VERSION=$(polycli version 2>&1 | head -n1 || echo "unknown")
                      log_json "info" "polygon-cli installed successfully: $POLYCLI_VERSION" "" "install_polycli"
                    else
                      log_json "error" "Failed to verify polygon-cli installation" "" "install_polycli"
                      exit 1
                    fi
                  else
                    log_json "error" "Failed to download polygon-cli" "" "install_polycli"
                    exit 1
                  fi

                  log_json "info" "Loading shared private key" "" "load_credentials"
                  private_key="{{ index $opSecrets.data "bridgeTesterPrivateKey" | b64dec }}"
                  log_json "info" "Private key loaded successfully" "" "load_credentials"

                  {{- $networks := .Values.config.networks }}
                  {{- $enabledNetworks := list }}
                  {{- range $networks }}
                  {{- if .enabled }}
                  {{- $enabledNetworks = append $enabledNetworks . }}
                  {{- end }}
                  {{- end }}

                  TOTAL_NETWORKS={{ len $enabledNetworks }}
                  log_json "info" "Processing $TOTAL_NETWORKS enabled network(s)" "" "process_networks"

                  CURRENT_NETWORK=0
                  FAILED_NETWORKS=()

                  {{- range $index, $network := $enabledNetworks }}

                  CURRENT_NETWORK=$((CURRENT_NETWORK + 1))
                  log_json "info" "Starting network $CURRENT_NETWORK/$TOTAL_NETWORKS" "{{ $network.name }}" "network_start"

                  log_json "info" "Preparing environment" "{{ $network.name }}" "prepare_env"
                  l1_rpc_url="{{ index $opSecrets.data "l1RpcURL" | b64dec }}"
                  l1_bridge_address="{{ $network.l1.bridgeAddress }}"
                  token_address="{{ $network.l1.tokenAddress }}"
                  destination_network="{{ $network.l2.networkId }}"
                  destination_address="{{ $network.l2.destinationAddress }}"
                  bridge_amount="{{ $network.bridgeAmount }}"

                  # Log configuration details
                  printf '{"timestamp":"%s","level":"info","message":"Network configuration","network":"{{ $network.name }}","step":"prepare_env","l1_bridge":"%s","l2_network_id":%s,"destination":"%s","amount":"%s","service":"bridge-tester","env":"{{ $.Values.env }}"}\n' "$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")" "$l1_bridge_address" "$destination_network" "$destination_address" "$bridge_amount"

                  log_json "info" "Executing bridge operation" "{{ $network.name }}" "bridge_asset"

                  # Execute polycli and capture output with exit code
                  set +e
                  BRIDGE_OUTPUT=$(polycli ulxly bridge asset \
                          --bridge-address $l1_bridge_address \
                          --destination-address $destination_address \
                          --private-key $private_key \
                          --value $bridge_amount \
                          --destination-network $destination_network \
                          --rpc-url $l1_rpc_url \
                          --token-address $token_address 2>&1)
                  BRIDGE_EXIT_CODE=$?
                  set -e

                  # Log polycli output as JSON
                  echo "$BRIDGE_OUTPUT" | while IFS= read -r line; do
                    [ -n "$line" ] && printf '{"timestamp":"%s","level":"debug","message":"%s","network":"{{ $network.name }}","step":"bridge_asset","source":"polycli","service":"bridge-tester","env":"{{ $.Values.env }}"}\n' "$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")" "$(echo "$line" | sed 's/"/\\"/g')"
                  done

                  if [ $BRIDGE_EXIT_CODE -eq 0 ]; then
                    log_json "info" "Bridge operation successful" "{{ $network.name }}" "bridge_asset"
                  else
                    log_json "error" "Bridge operation failed with exit code $BRIDGE_EXIT_CODE" "{{ $network.name }}" "bridge_asset"
                    FAILED_NETWORKS+=("{{ $network.name }}")
                  fi

                  # Wait between networks to avoid nonce conflicts
                  {{- if ne $index (sub (len $enabledNetworks) 1) }}
                  log_json "info" "Waiting 10 seconds before next network" "{{ $network.name }}" "delay"
                  sleep 10
                  {{- end }}

                  {{- end }}

                  # Generate summary
                  FAILED_COUNT=${#FAILED_NETWORKS[@]}
                  SUCCESS_COUNT=$((TOTAL_NETWORKS - FAILED_COUNT))

                  printf '{"timestamp":"%s","level":"info","message":"Job summary","step":"summary","total_networks":%d,"successful":%d,"failed":%d,"service":"bridge-tester","env":"{{ $.Values.env }}"}\n' "$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")" "$TOTAL_NETWORKS" "$SUCCESS_COUNT" "$FAILED_COUNT"

                  if [ $FAILED_COUNT -gt 0 ]; then
                    for network in "${FAILED_NETWORKS[@]}"; do
                      log_json "error" "Failed network in summary" "$network" "summary"
                    done
                    log_json "error" "Job completed with failures" "" "summary"
                    exit 1
                  else
                    log_json "info" "All bridge operations completed successfully" "" "summary"
                  fi

              resources:
                requests:
                  memory: "64Mi"
                  cpu: "250m"
                limits:
                  memory: "128Mi"
                  cpu: "500m"
          restartPolicy: Never
